<html>
<head>
    <title>Draggable Square</title>
    <style>
        body { margin:0; }
        canvas {
            background:#ddd;
            display:block;
            flex: 2;
        }
        .save-button {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        .load-button {
            position: absolute;
            top: 10px;
            right: 60px;
        }
        .update-button {
            position: absolute;
            top: 10px;
            right: 100px;
        }
        #container {
            display: flex;
            height: 100vh;
        }

        #properties {
            flex: 1;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="properties">
            <button class="save-button" onclick="saveDocumentation()">SAVE</button>
            <button class="load-button" onclick="loadDocumentation()">LOAD</button>
            <button class="update-button" onclick="updateDocumentation()">UPDATE</button>
            <textarea id="squareProperties" placeholder="Enter text here" style="margin-top: 50px;" rows="100"></textarea>
        </div>
    </div>


    <script>
        var canvas = document.getElementById('canvas');

        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth * (2 / 3);
            canvas.height = window.innerHeight;
            // Redraw your canvas here after resizing
        });

        window.addEventListener('load', function() {
            canvas.width = window.innerWidth * (2 / 3);
            canvas.height = window.innerHeight;
        });

        var ctx = canvas.getContext('2d');

        var canvasPos = getPosition(canvas);
        var mouseX = 0;
        var mouseY = 0;

        // Get file with documentation that needs to be visualized. Can be separate function
        //Not defined propery "active", false by default
        var documentation; // Declare the documentation variable outside the fetch function

        fetch('documentation.json')
            .then(response => response.json())
            .then(data => {
                documentation = data; // Assign the fetched data to the documentation variable
                processDocumentation(); // Call the function that depends on the fetched data
                console.log(documentation);
                update();
            })
            .catch(error => console.error('Error:', error));

        function processDocumentation() {
            documentation = documentation.map((document, index) => {
                if (document.id === undefined) {
                    throw new Error("ID field is missing in" ,index,"th element");
                }
                return {
                    id: document.id,
                    icon: document.icon !== undefined ? document.icon : "default_icon",
                    description: document.description !== undefined ? document.description : "default_icon",
                    parents: document.parents !== undefined ? document.parents : [],
                    groups: document.groups !== undefined ? document.groups : [],
                    show_level: document.show_level !== undefined ? document.show_level : 1,
                    viz: document.viz !== undefined ? document.viz : {x: 0,y: 0, size:50},
                }
            });

            // Rest of the code that depends on the processed documentation
        }

        function saveDocumentation() {
            localStorage.setItem('documentation', JSON.stringify(documentation));
        }

        function loadDocumentation() {
            var retrievedData = localStorage.getItem('documentation');
            documentation = JSON.parse(retrievedData);
        }
            
        function updateDocumentation() {
            // Get the user input from the squareProperties field
            var userInput = document.getElementById('squareProperties').value;
            var userInputParsed = JSON.parse(userInput);
            // Update the active square's description with the user input
            if (activeSquare) {
                let activeSquareIndex = documentation.findIndex(square => square.id === activeSquare.id);
                documentation[activeSquareIndex] = userInputParsed;
            }
        }

        
        var drag = false;
        var dragViewport = false;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        function getMouseRelPosition(e) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        
        /**
         * Returns the square that was clicked based on the mouse coordinates. Retuns null when clicked outside all squares.
         * @param {Object} mouse - The mouse object containing the x and y coordinates.
         * @returns {Object|null} - The clicked square object or null if no square was clicked.
         */
        function getClickedSquare(mouse) {
            var clickedSquare = null;
            documentation.forEach(function(square) {
                if (mouse.x > square.viz.x && mouse.x < square.viz.x + square.viz.size && mouse.y > square.viz.y && mouse.y < square.viz.y + square.viz.size) {
                    clickedSquare = square;
                }
            });
            return clickedSquare;
        }

        var activeSquare = null;
        function activateSquare(square) {
            square.active = true;
            activeSquare = square;

            var squarePropertiesInput = document.getElementById('squareProperties');
            squarePropertiesInput.value = JSON.stringify(activeSquare, null, 2);
        }

        function deactivateAllSquares() {
            //TODO: Loop through all active when there can be all active
            if (activeSquare) {
                activeSquare.active = false;
                activeSquare = null;
            }
        }

        canvas.addEventListener('mousedown', function (e) {
            var mouse = getMouseRelPosition(e);
            var clickedSquare = getClickedSquare(mouse);
            
            if (clickedSquare) {
                clickedSquare.drag = true;
            } else {
                dragViewport = true;
                viewportX = mouse.x;
                viewportY = mouse.y;
            }
        });

        canvas.addEventListener('mouseup', function () {
            documentation.forEach(function(square) {
                square.drag = false;
            });
            dragViewport = false;
        });

        canvas.addEventListener('mousemove', function (e) {
            mouseX = e.clientX - canvasPos.x;
            mouseY = e.clientY - canvasPos.y;
            documentation.forEach(function(square) {
                if (square.drag) {
                    square.viz.x = mouseX - square.viz.size / 2;
                    square.viz.y = mouseY - square.viz.size / 2;
                }
            });
            if (dragViewport) {
                var dx = mouseX - viewportX;
                var dy = mouseY - viewportY;
                documentation.forEach(function(square) {
                    square.viz.x += dx;
                    square.viz.y += dy;
                });
                viewportX = mouseX;
                viewportY = mouseY;
            }
        });

        canvas.addEventListener("click", function (e) {
            var mouse = getMouseRelPosition(e);
            var clickedSquare = getClickedSquare(mouse);
            if(clickedSquare) {
                deactivateAllSquares();
                activateSquare(clickedSquare);
            } else {
                deactivateAllSquares();
            }
        });

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draws squares for groups
            // TODO This calculation should not be done each frame
            let groups = documentation.map(item => item.groups);
            let uniqueGroups = [...new Set(groups)];

            uniqueGroups.forEach(function(group) {
                let filteredSquares = documentation.filter(item => item.groups === group);

                // Initialize variables for minimum and maximum coordinates
                let minX = Number.MAX_VALUE;
                let minY = Number.MAX_VALUE;
                let maxX = Number.MIN_VALUE;
                let maxY = Number.MIN_VALUE;

                filteredSquares.forEach(function(square) {
                    // Update minimum and maximum x coordinates
                    minX = Math.min(minX, square.viz.x);
                    maxX = Math.max(maxX, square.viz.x);

                    // Update minimum and maximum y coordinates
                    minY = Math.min(minY, square.viz.y);
                    maxY = Math.max(maxY, square.viz.y);
                });
                ctx.fillStyle = "grey";
                ctx.fillRect(minX, minY, maxX - minX + 70, maxY - minY + 70);
            });

            // Draws icons
            documentation.forEach(function(square) {

                
                if(square.active) {
                    ctx.fillStyle = "blue";
                    ctx.fillRect(square.viz.x, square.viz.y, 50,50);
                } else {
                    var icon = new Image();
                    icon.src = square.icon;
                    ctx.drawImage(icon, square.viz.x, square.viz.y, 50, 50);
                }

                ctx.fillStyle = "black";
                ctx.font = "12px Consolas";
                ctx.fillText(square.id, square.viz.x + 20, square.viz.y + 70);
                
                // Draw arrows from parent squares
                square.parents.forEach(function(parentId) {
                    var parentSquare = documentation.find(function(square) {
                        return square.id === parentId;
                    });
                    
                    if (parentSquare) {


                        // Calculate the midpoint between the parent square and the current square

                        var diffX = parentSquare.viz.x - square.viz.x
                        var diffY = parentSquare.viz.y - square.viz.y
                        var midX = (parentSquare.viz.x + square.viz.x) / 2;
                        var midY = (parentSquare.viz.y + square.viz.y) / 2;

                        var startX, startY
                        var endX, endY
                        // Drawing lines. probably not optimal and should be cached not calculated every time
                        ctx.beginPath();
                        if (Math.abs(diffX) < Math.abs(diffY)) {
                            //First line vertical

                            // Check start square
                            if (diffY > 0) {
                                startX = parentSquare.viz.x + 25 //point to the TOP
                                startY = parentSquare.viz.y
                            } else {
                                startX = parentSquare.viz.x + 25 //point to the BOTTOM
                                startY = parentSquare.viz.y + 50
                            }
                            // Check end square
                            if (diffX > 0) {
                                
                                endX = square.viz.x + 50 //point to the LEFT
                                endY = square.viz.y + 25
                            } else {
                                endX = square.viz.x //point to the RIGHT
                                endY = square.viz.y + 25
                            }
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(startX, midY);
                            ctx.lineTo(endX,endY)
                        } else {
                            //First line horizontal
                            if (diffX > 0) {
                                
                                startX = parentSquare.viz.x //point to the LEFT
                                startY = parentSquare.viz.y + 25
                                ctx.moveTo(startX, startY);
                            } else {
                                startX = parentSquare.viz.x + 50//point to the RIGHT
                                startY = parentSquare.viz.y + 25
                                ctx.moveTo(startX, startY);
                            }
                            // Check end square
                            if (diffY > 0) {
                                endX = square.viz.x + 25 //point to the BOTTOM
                                endY = square.viz.y + 50
                            } else {
                                endX = square.viz.x +25 //point to the TOP
                                endY = square.viz.y
                            }
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(midX, startY);
                            ctx.lineTo(endX,endY)
                        }
                        
                        
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(endX, endY, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = "black";
                        ctx.fill();
                        ctx.closePath();
                    }
                });
            });
            
            requestAnimationFrame(update);
        }
        function getPosition(el) {
            var xPosition = 0;
            var yPosition = 0;

            while (el) {
                xPosition += (el.offsetLeft - el.scrollLeft + el.clientLeft);
                yPosition += (el.offsetTop - el.scrollTop + el.clientTop);
                el = el.offsetParent;
            }
            return {
                x: xPosition,
                y: yPosition
            };
        }

    </script>
</body>
</html>